
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    
    _global = []
    
    # get the table
    T = []
    for row in cur:
        if True:
            T.append(row)
    
    # create structure for mf_struct
    class struct:
        def __init__(self, cust, count_1_quant, sum_1_quant, avg_1_quant, count_2_quant, sum_2_quant, avg_2_quant, count_3_quant, sum_3_quant, avg_3_quant):
            self.cust = cust
            self.count_1_quant = count_1_quant
            self.sum_1_quant = sum_1_quant
            self.avg_1_quant = avg_1_quant
            self.count_2_quant = count_2_quant
            self.sum_2_quant = sum_2_quant
            self.avg_2_quant = avg_2_quant
            self.count_3_quant = count_3_quant
            self.sum_3_quant = sum_3_quant
            self.avg_3_quant = avg_3_quant
            

    # scan table to fill mf_struct
    mf_struct = []
    for row in T:
        if next((i for i, e in enumerate(mf_struct) if e.cust == row['cust']), -1) != -1:
            continue
        else:
            mf_struct.append(struct(row['cust'], 0, 0, 0, 0, 0, 0, 0, 0, 0))

    # start scanning to calculate aggregates
    for sc in range(4):
        for row in T:
            for i, e in enumerate(mf_struct):
                # check if grouping variable is satisfied
                if e.cust == row['cust'] and ((sc == 0) or (sc == 1 and row['state'] == 'NY') or (sc == 2 and row['state'] == 'NJ') or (sc == 3 and row['state'] == 'CT')):
                    # update aggregates
                    match sc:
                        case 0:
                            pass
                        case 1:
                            mf_struct[i].count_1_quant = mf_struct[i].count_1_quant + 1
                            mf_struct[i].sum_1_quant = mf_struct[i].sum_1_quant + row['quant']
                            mf_struct[i].avg_1_quant = mf_struct[i].sum_1_quant / mf_struct[i].count_1_quant
                            
                        case 2:
                            mf_struct[i].count_2_quant = mf_struct[i].count_2_quant + 1
                            mf_struct[i].sum_2_quant = mf_struct[i].sum_2_quant + row['quant']
                            mf_struct[i].avg_2_quant = mf_struct[i].sum_2_quant / mf_struct[i].count_2_quant
                            
                        case 3:
                            mf_struct[i].count_3_quant = mf_struct[i].count_3_quant + 1
                            mf_struct[i].sum_3_quant = mf_struct[i].sum_3_quant + row['quant']
                            mf_struct[i].avg_3_quant = mf_struct[i].sum_3_quant / mf_struct[i].count_3_quant
                            
                else:
                    continue 

    # construct output in _global with having in mind
    for e in mf_struct:
        if e.avg_1_quant > e.avg_2_quant or e.avg_1_quant > e.avg_3_quant:
            _global.append([e.cust, e.avg_1_quant, e.avg_2_quant, e.avg_3_quant])
    
    
    return tabulate.tabulate(_global, headers=['cust', 'avg_1_quant', 'avg_2_quant', 'avg_3_quant'], tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    